# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# The bigMap Package for R.

# Copyright (c) 2018, Joan Garriga <jgarriga@ceab.csic.es>, Frederic Bartumeus <fbartu@ceab.csic.es> (Blanes Centre for Advanced Studies, CEAB-CSIC).

# bigMap is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

# bigMap is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#' Example dataset
#'
#' Loads a mapping example.
#'
#' @return An example dataset named \code{ex}
#'
#' @details Object \code{ex} is a list with elements: \var{ex$data} a matrix with raw data; \var{ex$labels} a vector of datapoint labels; \var{ex$map} is a \code{bdm} instance: a list with the results of the mapping protocol.
#'
#' This example is based on a small synthetic dataset with \code{n = 5000} observations drawn from a 4-variate Gaussian Mixture Model (GMM) with 16 Gaussian components with random means and variances.
#'
#' @examples
#'
#' # --- load example dataset
#' bdm.example()
#' str(ex)

bdm.example <- function()
{
	load(paste(paste(system.file('extdata', package = 'bigMap'), '/', sep = ''), 'exMap.RData', sep=''), envir=parent.frame(), verbose=T)
}


#' Create \var{bdm} instance
#'
#' Computes the precision parameters beta_i for the given perplexity (local bandwidths for the input affinity kernels) and returns them in a \var{bdm} instance. A \var{bdm} instance is a list with the supplied info (type of inpu data and perplexity) and the precision parameters that have been computed. This list is the starting object to which new elements are added at each step of the mapping protocol.
#'
#' @param dSet.data A \var{data.frame} or \var{matrix} with raw input-data. The dataset must not have duplicated rows.
#'
#' @param is.distance A logical value (FALSE by default). TRUE indicates that raw data is a distance matrix.
#'
#' @param is.sparse A logical value (FALSE by default). TRUE indicates that the raw data is a sparse matrix.
#'
#' @param ppx The value of perplexity to compute similarities (default value is 100).
#'
#' @param mpi.cl MPI (inter-node parallelization) cluster as generated by \code{bdm.mpi.start()}. (By default \code{mpi.cl = NULL} a 'SOCK' (intra-node parallelization) cluster is generated).
#'
#' @param threads Number of parallel threads (according to data size and hardware resources, \code{i.e.} number of cores and available memory. Default value is \code{threads = 4}).
#'
#' @param dSet.labels If available, labels can be included as a separate vector of length equal to \code{nrow(dSet.data)}. Label values are factorized as \code{as.numeric(as.factor(labels))}.
#'
#' @return A \var{bdm} instance. A \var{bdm} instance is a list with the supplied info and the precision parameters computed for the given perplexity. This list is the starting object to which new elements are added at each step of the mapping protocol.
#'
#' @examples
#'
#' # --- load example dataset
#' bdm.example()
#' \dontrun{
#' m <- bdm.init(ex$data, ppx = 250, labels = ex$labels)
#' }

bdm.init <- function(dSet.data, is.distance = F, is.sparse = F, ppx = 100, mpi.cl = NULL, threads = 4, dSet.labels = NULL)
{
	bdm <- list()
	# check dSet.data is given as fileName.csv
	if (class(dSet.data) == 'character') {
	 	if (!file.exists(dSet.data)) {
			message('+++ Data file not found !! \n')
			return(FALSE)
		}
		bdm$dataFile <- dSet.data
	}
	bdm$is.distance <- is.distance
	bdm$is.sparse <- is.sparse
	bdm$normalize <- normalize
	# compute betas
	if (threads > 0) {
		# start cluster
		cl <- cluster.start(threads, mpi.cl)
		# export data
		cat('+++ exporting data \n')
		t <- system.time({
			Xdata.exp(cl, dSet.data, is.distance, is.sparse, normalize = normalize)
		})
		print(t)
		dimX <- Xdata.dim(cl)
		bdm$nX <- dimX[1]
		bdm$mX <- dimX[2]
		# compute betas
		if (length(ppx) == 1) {
			bdm$ppx <- list(beta.get(cl, ppx, xppx = xppx))
		} else {
			bdm$ppx <- lapply(ppx, function(ppx_i) beta.get(cl, ppx_i, xppx = xppx))
		}
		# stop cluster
		if (is.null(mpi.cl)) cluster.stop(cl)
	}
	# attach labels
	if (!is.null(dSet.labels)) bdm$lbls <- as.numeric(as.factor(dSet.labels))
	return(bdm)
}

#' Parallelized t-SNE (ptSNE)
#'
#' Starts the parallelized t-SNE algorithm (pt-SNE). This is the first step of the mapping protocol.
#'
#' @param dSet.data Input data (a matrix, a big.matrix or a .csv file name).
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.init()}.
#'
#' @param theta Accuracy/speed trade-off factor, a value between 0.33 and 0.8. (Default value is \code{theta = 0.0}). If \code{theta < 0.33} the algorithm uses the exact computation of the gradient. The closer is this value to 1 the faster is the computation but the coarser is the approximation of the gradient.
#'
#' @param Y.init A \code{n *2 *layers} matrix with initial mapping positions. (By default \code{Y.init=NULL} will use random initial positions).
#'
#' @param mpi.cl MPI (inter-node parallelization) cluster as generated by \code{bdm.mpi.start()}. (By default \code{mpi.cl = NULL} a 'SOCK' (intra-node parallelization) cluster is generated).
#'
#' @param threads Number of parallel threads (according to data size and hardware resources, \code{i.e.} number of cores and available memory. Default value is \code{threads = 4}).
#'
#' @param layers Number of layers (\code{minimum} 2, \code{maximum} the number of threads).
#'
#' @param info Output information: 1 yields inter-round results, 0 disables intermediate results. Default value is 0.
#'
#' @return A copy of the input \var{bdm} instance with new element \var{bdm$ptsne} (t-SNE output).
#'
#' @examples
#'
#' # --- load example dataset
#' bdm.example()
#' # --- perform ptSNE
#' \dontrun{
#' m <- bdm.ptsne(ex$data, ex$map, threads = 10, layers = 2)
#' # --- plot the Cost function
#' bdm.cost(m)
#' # --- plot ptSNE output
#' bdm.ptsne.plot(m, class.lbls = ex$labels)
#' }

bdm.ptsne <- function(dSet.data, bdm, theta = 0.5, Y.init = NULL, mpi.cl = NULL, threads = 4, layers = 2, info = 0)
{
	# +++ sanity check
	if (!is.null(Y.init) && (ncol(Y.init) != 2 *layers)) {
		return(message('+++ ncol(Y.init) does not match the number of layers !! \n'))
	}
	if (layers > threads) {
		cat('+++ WARNING: layers set to ', threads, ' !!\n', sep='')
		layers <- threads
	}
	if (theta > 0.0 && theta < 0.33) {
		cat('+++ WARNING: theta set to ', 0.0, ' !!\n', sep='')
		theta <- 0.0
	} else if (theta > 0.8) {
		cat('+++ WARNING: theta set to ', 0.8, ' !!\n', sep='')
		theta <- 0.8
	}
	# +++ start cluster of workers
	bdm$t <- list()
	cl <- cluster.start(threads, mpi.cl)
	if (is.null(cl)) return(bdm)
	# export data (if using mpi.cl it might have been already exported)
	if (is.null(mpi.cl) || !is.null(dSet.data)) {
		cat('+++ exporting data \n')
		bdm$t$dataExport <- system.time({
			Xdata.exp(cl, dSet.data, bdm$is.distance, bdm$is.sparse, normalize = bdm$normalize)
		})
		print(bdm$t$dataExport)
	}
	#
	bdm$ptsne <- list(threads = threads, layers = layers, theta = theta, gain = gain, momentum = momentum, qDecay = qDecay, Y = Y.init)
	#
	bdm <- ptsne.get(cl, bdm, info)
	if (length(bdm) == 1) bdm <- bdm[[1]]
	# stop cluster
	cluster.stop(cl)
	return(bdm)
}

#' Restart pt-SNE
#'
#' Restarts the ptSNE algorithm (runs more epochs).
#'
#' @param dSet.data Input data (a matrix, a big.matrix or a .csv file name).
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.init()}.
#'
#' @param epochs Number of epochs to run. Default value \code{epochs = NULL} runs \code{4 *log(n)} epochs.
#'
#' @param iters Number of iters/epoch. Default value \code{iters = NULL} runs \code{4 *log(thread_size)} iters/epoch.
#'
#' @param mpi.cl MPI (inter-node parallelization) cluster as generated by \code{bdm.mpi.start()}. (By default \code{mpi.cl = NULL} a 'SOCK' (intra-node parallelization) cluster is generated).
#'
#' @param threads Number of parallel threads (according to data size and hardware resources, \code{i.e.} number of cores and available memory. Default value is \code{threads = 4}).
#'
#' @param layers Number of layers (\code{minimum} 2, \code{maximum} the number of threads).
#'
#' @param info Output information: 1 yields inter-round results, 0 disables intermediate results. Default value is 0.
#'
#' @return A copy of the input \var{bdm} instance with new element \var{bdm$ptsne} (t-SNE output).
#'
#' @examples
#'
#' # --- load example dataset
#' bdm.example()
#' # --- perform ptSNE
#' \dontrun{
#' m <- bdm.restart(ex$data, ex$map, epochs = 50)
#' }

bdm.restart <- function(dSet.data, bdm, epochs = NULL, iters = NULL, mpi.cl = NULL, threads = NULL, layers = NULL, info = 0) {
	# +++ start cluster of workers
	if (!is.null(threads)) bdm$ptsne$threads <- threads
	if (!is.null(layers)) bdm$ptsne$layers <- layers
	cl <- cluster.start(bdm$ptsne$threads, mpi.cl)
	if (is.null(cl)) return(bdm)
	# export data (if using mpi.cl it might have been already exported)
	if (is.null(mpi.cl) || !is.null(dSet.data)) {
		cat('+++ exporting data \n')
		Xdata.exp(cl, dSet.data, bdm$is.distance, bdm$is.sparse, normalize = bdm$normalize)
	}
	# +++ run ptsne
	if (!is.null(epochs)) bdm$epochs <- epochs
	if (!is.null(iters)) bdm$iters <- iters
	cost <- bdm$ptsne$cost
	size <- bdm$ptsne$size
	bdm <- ptsne.restart(cl, bdm, info)
	if (!is.null(cost)) {
		if (bdm$ptsne$threads > 1) {
		 	if (nrow(cost) == nrow(bdm$ptsne$cost)) {
				bdm$ptsne$cost <- cbind(cost, bdm$ptsne$cost)
			}
		} else {
			bdm$ptsne$cost <- c(cost, bdm$ptsne$cost)
		}
	}
	bdm$ptsne$size <- c(size, bdm$ptsne$size)
	# +++ stop cluster
	cluster.stop(cl)
	return(bdm)
}

#' Perplexity-adaptive kernel density estimation
#'
#' Starts the paKDE algorithm (second step of the mapping protocol).
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.init()}.
#'
#' @param ppx The value of perplexity to compute similarities in the low-dimensional embedding. Default value is \code{ppx = 100}.
#'
#' @param g The resolution of the density space grid (\eqn{g*g} cells). Default value is \code{g = 200}.
#'
#' @param g.exp A numeric factor to avoid border effects. The grid limits will be expanded so as to enclose the density of the kernel of the most extreme embedded datapoints up to \code{g.exp} times \eqn{\sigma}. Default value is \code{g.exp = 3}, \code{i.e.} the grid limits are expanded so as to enclose the 0.9986 of the probability mass of the most extreme kernels.
#'
#' @param mpi.cl MPI (inter-node parallelization) cluster as generated by \code{bdm.mpi.start()}. Default value is \code{mpi.cl = NULL}. By default a 'SOCK' (intra-node parallelization) cluster is generated.
#'
#' @param threads Number of parallel threads (according to data size and hardware resources, \code{i.e.} number of cores and available memory. Default value is \code{threads = 4}).
#'
#' @param layer The number of the t-SNE layer. Default value is \code{layer = 1}.
#'
#' @details When computing the \var{paKDE} the embedding area is discretized as a grid of size \code{g*g} cells. In order to avoid border effects, the limits of the grid are expanded by default so as to enclose at least the 0.9986 of the cumulative distribution function (\eqn{3 \sigma}) of the kernels of the most extreme mapped points in each direction.
#'
#' The presence of outliers in the embedding can lead to undesired expansion of the grid limits. We can overcome this using lower values of \var{g.exp}. By setting \code{g.exp = 0} the grid limits will be equal to the range of the embedding.
#'
#' The values \var{g.exp = c(1, 2, 3, 4, 5, 6)} enclose cdf values of \var{0.8413, 0.9772, 0.9986, 0.99996, 0.99999, 1.0} respectively.
#'
#' @return A copy of the input \var{bdm} instance with new element \var{bdm$pakde} (paKDE output). \code{bdm$pakde[[layer]]$layer = 'NC'} stands for not computed layers.
#'

#' @examples
#'
#' # --- load mapped dataset
#' bdm.example()
#' # --- run paKDE
#' \dontrun{
#' m <- bdm.pakde(ex$map, ppx = 200, g = 200, g.exp = 3, threads = 4)
#' # --- plot paKDE output
#' bdm.pakde.plot(m)
#' }

bdm.pakde <- function(bdm, ppx = 100, g = 200, g.exp = 3, mpi.cl = NULL, threads = 2, layer = 1)
{
	# start cluster of workers
	cl <- cluster.start(threads, mpi.cl)
	if (is.null(cl)) return(bdm)
	# initialize bdm$pakde
	if (is.null(bdm$pakde)) bdm$pakde <- list()
	# compute kde
	l <- c(1, 2) + (layer- 1) *2
	if (!is.null(bdm$ptsne$Y[ , l])) {
		cat('+++ paKDE for layer ', layer, '/', bdm$ptsne$layers, ' +++ \n', sep='')
		bdm$pakde[[layer]] <- pakde.get(cl, bdm$ptsne$Y[ , l], ppx, g, g.exp)
	}
	else cat('+++ Error: up-stream step bdm.ptsne(layer = ', layer, ') not found ! \n', sep = '')
	# stop cluster
	cluster.stop(cl)
	return(bdm)
}


#' Watertrack transform (WTT)
#'
#' Starts the WTT algorithm (third setp of the mapping protocol).
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.init()}.
#'
#' @param layer The number of the t-SNE layer. Default value is \code{layer = 1}.
#'
#' @return A copy of the input \var{bdm} instance with \var{bdm$wtt} (WTT output).
#'
#' @details This function requires the up-stream step \code{bdm.pakde()}.
#'
#' @examples
#'
#' # --- load mapped dataset
#' bdm.example()
#' # --- perform WTT
#' m <- bdm.wtt(ex$map)
#' # --- plot WTT output
#' bdm.wtt.plot(m)

bdm.wtt <- function(bdm, layer = 1)
{
	# initialize bdm$wtt
	if (is.null(bdm$wtt)) bdm$wtt <- list()
	# compute WTT
	if (!is.null(bdm$pakde[[layer]]$z))
	{
		cat('\n')
		cat('+++ WTT for layer ', layer, '/', bdm$ptsne$layers, ' +++ \n', sep='')
		bdm$wtt[[layer]] <- wtt.get(bdm$pakde[[layer]])
	}
	else cat('+++ Error: up-stream step bdm.pakde(layer = ', layer, ') not found ! \n', sep = '')
	return(bdm)
}


#' Get data-point clustering labels.
#'
#' Given that clusters are computed at grid-cell level, this function returns the clustering label for each data-point.
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.init()}.
#'
#' @param layer The number of the t-SNE layer. Default value is \code{layer = 1}.
#'
#' @param merged Default value is \code{merged = TRUE}. If \code{merged = TRUE} and \code{!is.null(bdm$merge)}, labels are the ids of the clusters after merging. If \code{merged = FALSE} or \code{is.null(bdm$merge)} labels indicate the ids of to the top-level clustering.
#'
#' @return A vector of data-point clustering labels.
#'
#' @examples
#'
#' bdm.example()
#' m.labels <- bdm.labels(ex$map)

bdm.labels <- function(bdm, merged = T, layer = 1){
	# At.!!! there is an internal version of this function (for simplicity)
	# check merge.labels() in bdm_merge.R if any change is to be made here !!
	if (!is.null(bdm$wtt[[layer]]))
	{
		C <- bdm$wtt[[layer]]$C
		if (merged && !is.null(bdm$merge)) {
			C <- bdm$merge$C
		}
		l <- c(1, 2) + (layer -1) *2
		D2c <- grid_D2cell(bdm$ptsne$Y[ , l], bdm$wtt[[layer]]$grid) +1
		x.size <- bdm$wtt[[layer]]$grid[1, 1]
		lbls <- C[(D2c[, 2] - 1) *x.size +D2c[, 1]]
	}
	else {
		lbls <- rep(1, nrow(bdm$ptsne$Y))
	}
	return(lbls)
}
