# +++ The bigMap Package for R.

# Copyright (c) 2018, Joan Garriga <jgarriga@ceab.csic.es>, Frederic Bartumeus <fbartu@ceab.csic.es> (Blanes Centre for Advanced Studies, CEAB-CSIC).

# bigMap is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

# bigMap is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses.

# +++

#' k-ary Neighborhood Preservation
#'
#' A measure of matching between HD and LD neighborhoods ('Multi-scale similarities in stochastic neighbour embedding: Reducing dimensionality while preserving both local and global structure', Lee et. al 2015).
#'
#' @param data Input data (a matrix, a big.matrix or a .csv file name).
#'
#' @param bdm A \var{bdm} instance as generated by \code{bdm.ptsne()}.
#'
#' @param k.max Maximum neighborhood size to check. (By default \code{k.max=NULL} neighborhood sizes are checked up to n-1).
#'
#' @param sampling Fraction of data points to check for each neighborhood size. (Default value is \code{sampling=0.9}).
#'
#' @param threads The number of parallel threads (according to data size and hardware resources, \code{i.e.} number of cores and available memory. Default value is \code{threads = 4}).
#'
#' @param mpi.cl An MPI (inter-node parallelization) cluster as generated by \code{bdm.mpi.start()}. (By default \code{mpi.cl = NULL} a 'SOCK' (intra-node parallelization) cluster is generated).
#'
#' @return A copy of the input \var{bdm} instance with new element \var{bdm$knP}.
#'#'
#' @examples
#'
#' # --- load example dataset
#' \dontrun{
#' bdm.example()
#' m <- bdm.knp(exData[, 1:4], exMap, threads = 4)
#' }
#'

bdm.knp <- function(data, bdm, k.max = NULL, sampling = 0.9, threads = 4, mpi.cl = NULL)
{
	#. start cluster of workers
	cl <- cluster.start(threads, mpi.cl)
	if (is.null(cl)) return(bdm)
	# . input data (if using mpi.cl it might have been already exported)
	if (is.null(mpi.cl) || !is.null(data)) {
		cat('+++ exporting input data \n')
		Xdata.exp(cl, data, bdm$is.distance, bdm$is.sparse, bdm$normalize)
	}
	#. output data
	cat('+++ exporting output data \n')
	Ydata.exp(cl, bdm$ptsne$Y[, 1:2])
	cat('+++ computing k-ary neighbourhood preservation \n')
	nY <- nrow(bdm$ptsne$Y)
	if (is.null(k.max)) k.max <- nY -1
	t <- system.time({
		bdm$knQ <- qlty.get.kn(cl, nY, k.max, sampling)
	})
	cat('+++ linAUC', bdm$knQ$AUC[1], ', logAUC', bdm$knQ$AUC[2], '\n', sep = ' ')
	print(t)
	stopCluster(cl)
	return(bdm)
}

# ------------------------------------------------------------------------------
# +++ knp internal functions
# ------------------------------------------------------------------------------

qlty.get.kn <- function(cl, nY, k.max, sampling)
{
	#. k-ary neighborhoods
	K <- unique(ceiling(2**(seq(1, log2(k.max -4), length.out = 100))))
	#. k-ary Q
	clusterExport(cl, c('K', 'sampling'), envir = environment())
	Q.list <- clusterCall(cl, thread.qlty.kn)
	Q <- sapply(Q.list[2: length(Q.list)], function(chnk.Q) apply(chnk.Q, 2, sum))
	n <- sum(sapply(Q.list[2: length(Q.list)], function(chnk.Q) nrow(chnk.Q)))
	Q <- apply(Q, 1, sum) /(K *n)
	R <- sapply((ceiling((nY -1) *Q) -K), function(q) max(q, 0)) /(nY -1 -K)
	linAUC <- sum(R * (K -c(1, K[1:(length(K) -1)]))) / K[length(K)]
	logAUC <- sum(R /log10(K)) / sum(1 /log10(K))
	return(list(k.max = k.max, sampling = sampling, K = K, Q = Q, R = R, AUC = c(linAUC, logAUC)))
}

thread.qlty.kn <- function()
{
	if (thread.rank != 0) {
		z_knQlty(thread.rank, threads, Xbm@address, Ybm@address, is.distance, is.sparse, K, sampling)
	}
}

thread.qlty.kn.R <- function()
{
	if (thread.rank == 0) return(0)
	chnk.brks <- round(seq(1, n +1, length.out = (threads +1)), 0)
	chnk.size <- chnk.brks[thread.rank +1] -chnk.brks[thread.rank]
	chnk.Q <- matrix(rep(0, chnk.size *length(K)), c(chnk.size, length(K)))
	#. squared Y components
	Y2 <- apply(Ybm[, ]**2, 1, sum)
	#. squared X components
	if (!is.distance && !is.sparse) X2 <- apply(Xbm[, ]**2, 1, sum)
	#
	z <- 1
	for (i in chnk.brks[thread.rank]:(chnk.brks[thread.rank +1] -1))
	{
		# H-space distance/ranks
		if (is.distance) {
			Hij <- sort(Xbm[i, ], index.return = T)$ix
		} else if (is.sparse) {
			Dij <- sprsDist_R(Xbm@address, (i -1))	# C++ indexes
			Hij <- sort(Dij, index.return = T)$ix
		} else {
			Dij <- X2[i] +X2 -2 *(Xbm[i, ] %*%  t(Xbm[, ]))
			Hij <- sort(Dij, index.return = T)$ix
		}
		# L-space distance/ranks
		Dij <- Y2[i] +Y2 -2 *(Ybm[i, ] %*%  t(Ybm[, ]))
		Lij <- sort(Dij, index.return = T)$ix
		# k-ary preservation
		chnk.Q[z, ] <- sapply(K, function(k) length(intersect(Hij[1:k], Lij[1:k])))
		z <- z +1
	}
	return(chnk.Q)
}


# -----------------------------------------------------------------------------
# +++ knp plot
# ------------------------------------------------------------------------------

bdm.knp.plot <- function(bdm, ppxfrmt = 0)
{
	if (is.null(bdm$dSet)) qlty.plot.kn.list(bdm, ppxfrmt = ppxfrmt)
	else qlty.plot.kn(bdm)
}

qlty.plot.kn <- function(bdm, par.set = T)
{
	if (par.set) {
		parbdm.set(oma = c(2.0, 2.0, 2.0, 2.0), mar = c(3.0, 3.0, 1.5, 1.5))
		layout(matrix(1:2, nrow = 2))
	}
	# plot R vs K
	plot(bdm$knQ$K, bdm$knQ$R, type = 'l', col = 4, xlab = 'K', ylab = 'Rnx(K)', ylim= c(0.0, 1.0))
	# plot R vs log10(K)
	plot(log10(bdm$knQ$K), bdm$knQ$R, type = 'l', col = 4, xlab = 'log10(K)', ylab = 'Rnx(K)', ylim= c(0.0, 1.0))
	# title AUC
	ppx <- dotfrmt(bdm$ppx$ppx /nrow(bdm$ptsne$Y), 3)
	linAUC <- knformat(bdm$knQ$AUC[1], 4)
	logAUC <- knformat(bdm$knQ$AUC[2], 4)
	title(main = paste('ppx ', ppx, ' linAUC ', linAUC, ' logAUC ', logAUC), cex.main = 0.8)
	#
	if (par.set) parbdm.def()
}

qlty.plot.kn.list <- function(m.list, ppxfrmt = 1, log.k = T, par.set = T)
{
	if (par.set) {
		parbdm.set(oma = c(2.0, 2.0, 2.0, 2.0), mar = c(3.0, 3.0, 1.5, 1.5))
		layout(matrix(c(1, 2, 3, 3), nrow = 2), widths = c(0.7, 0.3))
	}
	# palette
	pltt <- rainbow(length(m.list))
	# plot R vs K
	K <- m.list[[1]]$knQ$K
	plot(K, rep(0, length(K)), type = 'n', xlab = 'K', ylab = 'Rnx(K)', ylim= c(0.0, 1.0))
	nulL <- lapply(seq_along(m.list), function(i) {
		bdm <- m.list[[i]]
		K <- bdm$knQ$K
		points(K, bdm$knQ$R, col = pltt[i], type = 'l')
	})
	# plot R vs log10(K)
	K <- log10(m.list[[1]]$knQ$K)
	plot(K, rep(0, length(K)), type = 'n', xlab = 'log10(K)', ylab = 'Rnx(K)', ylim= c(0.0, 1.0))
	nulL <- lapply(seq_along(m.list), function(i) {
		bdm <- m.list[[i]]
		K <- log10(bdm$knQ$K)
		points(K, bdm$knQ$R, col = pltt[i], type = 'l')
	})
	# plot legend
	par(mar = c(3.0, 1.0, 1.5, 0.5))
	plot(1, 1, xlab = '', ylab = '', xaxt = "n", yaxt = "n", bty = "n", type = "n")
	# legend text
	pltt <- c('#FFFFFF', pltt)
	legend.txt <- lapply(seq(0, length(m.list)), function(i) {
		if (i == 0) ' linAUC logAUC   ppx. '
		else {
			bdm <- m.list[[i]]
			linAUC <- knformat(bdm$knQ$AUC[1], 4)
			logAUC <- knformat(bdm$knQ$AUC[2], 4)
			if (ppxfrmt == 0) {
				ppx <- format(bdm$ppx$ppx, width = 6)
			} else {
				ppx <- format(round(bdm$ppx$ppx /nrow(bdm$ptsne$Y), ppxfrmt), scientific = T)
			}
			paste(' ', linAUC, '    ', logAUC, '    ', ppx, sep = '')
		}
	})
	legend('left', legend = legend.txt, bty = 'n', pch = 15, cex = 1.0, pt.cex = 1.0, col = pltt)
	#
	if (par.set) parbdm.def()
}

knformat <- function(x, d) paste('.', formatC(round(x *10**d, 0), width=d, flag=0), sep = '')
